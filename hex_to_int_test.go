package hex_to_int

import (
	"math/big"
	"testing"
)

type testNumber struct {
	hex, littleEn, bigEn string
}

var numbers = []testNumber{
	{"0xff00000000000000000000000000000000000000000000000000000000000000",
		"255",
		"115339776388732929035197660848497720713218148788040405586178452820382218977280"},
	{"0xaaaa000000000000000000000000000000000000000000000000000000000000",
		"43690",
		"77193548260167611359494267807458109956502771454495792280332974934474558013440"},
	{"0xffffffff",
		"4294967295",
		"4294967295"},
	{"0xf0000000000000000000000000000000000000000000000000000000000000000000000000000000000" +
		"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000" +
		"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000" +
		"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000" +
		"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000" +
		"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000" +
		"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000" +
		"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000" +
		"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000" +
		"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000" +
		"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000" +
		"000000000000000000000000000000000000000000000000000000000000000000000000000000000",
		"240",
		"9791145763248304750235181662968353586687164834819222941102188905787067887233351157957" +
			"751361890602109445844750447868089106133500982991815068092838323606549480743346655097281" +
			"234440889907509847359197763156361149495872277989119353556990678137665730499539032574144" +
			"116909725668287956938611960448137291721231521937690052908266760493252240283033696318121" +
			"057375932720024715875279153678359524741248759820770703379708373924607684233480447823406" +
			"882073236305995279454064272262646953909953204003140629848915934113327527038468596403463" +
			"236872017629345242223638360940532042699860870434701177033368734066365732358086834448364" +
			"3245345981859929366776014912359566883213308322140712831034206466859595407313125799576726" +
			"2426534143159642539179485013975461689493733866106312135829807129162654188209922755829012" +
			"3045826716715196783136097486468147450577243634621894902781834572964490141630775069496365" +
			"7023733410991091472858264030129434160553398387836878907142791318479490622365792012415325" +
			"6147359625549743656058746335124502376663710766611046750739680547042183503568549468592703" +
			"88209520798116101222496582960576830029761593978836870335394451411101101118419174029549125" +
			"52915450966807055340637210126254903687561404607916858777382328794063463346035669140691279" +
			"57053440"},
}

func TestHexToLittleEndian(t *testing.T) {
	expected := new(big.Int)
	for i := 0; i < len(numbers); i++ {
		expected, _ := expected.SetString(numbers[i].littleEn, 10)
		littleEn, err := HexToLittleEndian(numbers[i].hex)
		if err != nil {
			t.Fatalf("error appeared: %v", err)
		}
		if expected.Cmp(littleEn) != 0 {
			t.Fatalf("expected %q, actual %q", expected, littleEn)
		}
	}
}

func TestHexToBigEndian(t *testing.T) {
	expected := new(big.Int)
	for i := 0; i < len(numbers); i++ {
		expected, _ := expected.SetString(numbers[i].bigEn, 10)
		bigEn, err := HexToBigEndian(numbers[i].hex)
		if err != nil {
			t.Fatalf("error appeared: %v", err)
		}
		if expected.Cmp(bigEn) != 0 {
			t.Fatalf("expected %q, actual %q", expected, bigEn)
		}
	}
}

func TestLittleEndianToHex(t *testing.T) {
	littleEn := new(big.Int)
	for i := 0; i < len(numbers); i++ {
		littleEn, _ = littleEn.SetString(numbers[i].littleEn, 10)
		numOfBytes := NumberOfBytes(numbers[i].hex)

		if hex := LittleEndianToHex(littleEn, numOfBytes); hex != numbers[i].hex {
			t.Fatalf("expected %q, actual %q", numbers[i].hex, hex)
		}
	}
}

func TestBigEndianToHex(t *testing.T) {
	bigEn := new(big.Int)
	for i := 0; i < len(numbers); i++ {
		bigEn, _ = bigEn.SetString(numbers[i].bigEn, 10)
		numOfBytes := NumberOfBytes(numbers[i].hex)

		if hex := BigEndianToHex(bigEn, numOfBytes); hex != numbers[i].hex {
			t.Fatalf("expected %q, actual %q", numbers[i].hex, hex)
		}
	}
}
